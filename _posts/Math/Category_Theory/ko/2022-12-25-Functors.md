---

title: "함자들"
excerpt: "카테고리 사이의 함자들"

categories: [Math / Category Theory]
permalink: /ko/math/category_theory/functors
header:
    overlay_image: /assets/images/Category_theory/Functors.png
    overlay_filter: 0.5
sidebar: 
    nav: "category_theory-ko"

date: 2022-12-25
last_modified_at: 2022-12-25
weight: 2

---

범주론의 중요한 철학은 어떠한 수학적인 대상들이 주어진다면, 이들의 성질을 잘 보존하는 대상들 간의 morphism이 존재한다는 것이다. 이는 카테고리들도 예외가 아니다.

<div class="definition" markdown="1">

<ins id="df1">**정의 1**</ins> 두 카테고리 $\mathcal{A},\mathcal{B}$ 사이의 *functor<sub>함자</sub>* $F:\mathcal{A}\rightarrow \mathcal{B}$는 다음 데이터들

- $\obj(\mathcal{A})$에서 $\obj(\mathcal{B})$로의 함수 $A\mapsto F(A)$,
- 각각의 $A,A'\in\obj(\mathcal{A})$에 대하여, 함수 $\Mor_\mathcal{A}(A,A')\rightarrow\Mor_\mathcal{B}(FA,FA')$,

의 모임이며, 이들은 다음을 만족한다.

- $F$는 합성을 보존한다. 즉, $F(f'\circ f)=F(f')\circ F(f)$.
- $F$는 항등원을 보존한다. 즉 $F(\id_A)=\id_{F(A)}$.

</div>

대상들은 카테고리들이고, morphism들은 functor인 <em_ko>카테고리들의 카테고리</em_ko> $\CAT$ 또한 생각할 수 있겠지만, 러셀의 역설과 마찬가지 논리로 이러한 카테고리는 존재하지 않는다. 따라서 우리는 *small* category들의 카테고리 $\Cat$을 사용한다. 어찌되었건 functor들의 합성은 functor가 된다는 것은 자명하다.

## 함자의 예시들

<div class="example" markdown="1">

<ins id="ex2">**예시 2 (Forgetful functor)**</ins> 복잡한 카테고리에서 간단한 카테고리로 가는 *forgetful functor*들이 존재한다. 이들은 말 그대로 기존에 주어진 구조를 <em_ko>잊어버리는</em_ko> functor들이다. 몇 가지 예시를 통해 살펴보자.

- Forgetful functor $U:\Group\rightarrow\Set$은 다음과 같이 정의된다.
  
  - $U$는 임의의 $(G,\cdot,{}^{-1},e)\in\obj(\Group)$을 $G\in\obj(\Set)$에 대응시킨다.
  - $U$는 임의의 $f\in\Mor_\Group(G,H)$를 $f\in\Mor_\Set(G,H)$에 대응시킨다.

  즉, $U$는 단순히 $G$ 위의 연산과 항등원의 정보를 잊어버리고 이를 그냥 집합으로 보며, 또 group homomorphism이 group의 연산을 보존한다는 사실 또한 잊어버리고 이를 단순한 함수로 본다.
- 비슷하게, forgetful functor $U:\lmod{R}\rightarrow\Ab$이 정의된다. $U$는 $\lmod{R}$의 대상들에 스칼라곱이 있다는 사실을 잊어버리고 이를 abelian group으로 취급한다.
- 마찬가지로 abelian group의 구조를 잊어버리고 이를 집합으로 취급하는 forgetful functor $U:\Ab\rightarrow\Set$ 또한 존재한다. 앞선 forgetful functor와 이를 합성하면 $\lmod{R}$에서 $\Set$으로의 또 다른 forgetful functor를 얻는다.

</div>

<div class="example" markdown="1">

<ins id="ex3">**예시 3 (Free functor)**</ins> 

- 임의의 집합 $A$에 대하여, $A$를 generator로 갖는 *free group* $F(A)$가 잘 정의된다. 뿐만 아니라, free group의 universal property로부터, 임의의 $f:A\rightarrow B$가 주어질 때마다 다음의 diagram

  ![free_functor](/assets/images/Category_Theory.ko/Functors-1.png){:width="*0.15px" class="invert" .align-center}
  
  을 commute하도록 하는 $F(f):F(A)\rightarrow F(B)$가 유일하게 존재한다. 이렇게. $A\in\obj(\Set)$을 $F(A)\in\obj(\Group)$으로, $f\in\Mor_\Set(A,B)$를 $F(f)\in\Mor_\Group(FA,FB)$로 보내는 대응은 $\Set$에서 $\Group$으로의 functor가 된다.
- 마찬가지로 임의의 집합 $A$에 대하여, $A$를 generator로 갖는 *free left $R$-module* $F(A)$가 잘 정의되며, 위의 논의를 그대로 따라가서 functor $\Set\rightarrow\lmod{R}$을 얻을 수 있다.

</div>

다음 예시는 카테고리 $\lmod{R}$에서 $\Ab$으로의 functor들을 다룬다.

<div class="example" markdown="1">

<ins id="ex4">**예시 4 (Hom and tensor)**</ins> 

- 임의의 $M\in\obj(\lmod{R})$에 대하여, functor $\Hom_R(M,-):\lmod{R}\rightarrow\Ab$를 다음과 같이 정의할 수 있다. 
  - 임의의 $N\in\obj(\lmod{R})$에 대하여, $\Hom_R(M,-)(N)=\Hom_R(M,N)$이다. $\Hom_R(M,N)$은 자연스러운 방식으로 abelian group의 구조를 갖는다.
  - 임의의 morphism $f:N\rightarrow N'$에 대하여, $\Hom_R(M,-)(f)$는 다음의 대응

    $$\Hom_R(M,-):\Hom_R(M,N)\rightarrow\Hom_R(M,N');\qquad u\mapsto f\circ u$$

    으로 정의된다. 비슷하게 right $R$-module에 대해서도 $\Hom$ functor를 정의할 수 있다.
- 임의의 $M\in\obj(\rmod{R})$에 대하여, functor $M\otimes_R-:\lmod{R}\rightarrow\Ab$를 다음과 같이 정의할 수 있다.
  - 임의의 $N\in\obj(\lmod{R})$에 대하여, $(M\otimes_R-)(N)=M\otimes_RN$이다. 
  - 임의의 morphism $f:N\rightarrow N'$에 대하여, $(M\otimes_R-)(f)$는 다음 diagram

    ![functoriality_of_tensor](/assets/images/Category_Theory.ko/Functors-2.png){:width="*0.15px" class="invert" .align-center}

    에 universal property를 적용하여 얻어지는 $M\otimes_RN\rightarrow M\otimes_RN'$이다. 마찬가지로, 임의의 $N\in\obj(\lmod{R})$에 대하여, functor $-\otimes_RN:\rmod{R}\rightarrow\Ab$이 잘 정의된다.

</div>

## 공변함자와 반변함자

위의 [예시 4](#ex4)에서, 우리는 $\Hom$ functor $\Hom_R(-,N)$을 생각할 수도 있다. 그러나 텐서곱과는 다르게 $\Hom_R(-,N)$ 자체로는 말이 되는 정의를 얻기가 힘들다. 이는 $\Hom_R(-,N)$에 임의의 $f:M\rightarrow M'$을 넣었을 때 자연스럽게 얻어지는 대응이

$$\Hom_R(-,N):\Hom_R(M',N)\rightarrow\Hom_R(M,N);\qquad u\mapsto u\circ f$$

으로, [정의 1](#df1)과는 반대방향으로 화살표가 돌아가고 있기 때문이다. 그러나 이러한 경우를 다루기 위해 [§카테고리, ⁋정의 9](/ko/math/category_theory/categories#df9)에서 opposite category를 이미 정의했었다.

<div class="definition" markdown="1">

<ins id="df5">**정의 5**</ins> 두 카테고리 $\mathcal{A},\mathcal{B}$에 대하여, *contravariant functor<sub>반변함자</sub>*는 functor $\mathcal{A}^\op \rightarrow \mathcal{B}$를 의미한다.

</div>

강조가 필요할 때에는 [정의 1](#df1)의 functor들을 *covariant functor<sub>공변함자</sub>*라 부르기도 한다. 이 문단의 도입부에서 다룬 $\Hom$ functor $\Hom_R(-,N)$은 contravariant functor의 대표적인 예시이며, 특별히 $N=R$인 경우 이는 dual functor가 된다. 

## 부분카테고리

카테고리들 사이에 morphism에 해당하는 functor가 존재하듯이, 부분카테고리 또한 잘 정의된다. 표기의 편의상 다음 정의에서 $\subseteq$를 클래스들 사이의 포함관계로 둔다.

<div class="definition" markdown="1">

<ins id="df6">**정의 6**</ins> 카테고리 $\mathcal{C}$의 *subcategory<sub>부분카테고리</sub>* $\mathcal{B}$는 다음의 데이터들로 이루어진다.

- 대상들의 모임 $\obj(\mathcal{B})\subseteq\obj(\mathcal{C})$,
- 임의의 $A,B\in\obj(\mathcal{B})\subseteq\obj(\mathcal{C})$에 대하여, morphism들의 모임 $\Mor_\mathcal{B}(A,B)\subseteq\Mor_\mathcal{C}(A,B)$,

이들은 다음을 만족한다.

- Morphism들의 합성은 닫혀있다. 즉, 임의의 $A,B,C\in\obj(\mathcal{B})\subseteq\obj(\mathcal{C})$에 대하여, 만일

  $$f\in\Mor_\mathcal{B}(A,B)\subseteq\Mor_\mathcal{C}(A,B),\qquad g\in\Mor_\mathcal{B}(B,C)\subseteq\Mor_\mathcal{C}(B,C)$$

  이 성립한다면 $g\circ f\in\Mor_\mathcal{C}(A,C)$는 $\Mor_\mathcal{B}(A,C)$의 원소이기도 하다.
- 임의의 $B\in\obj(\mathcal{B})$에 대하여, $\Mor_\mathcal{B}(B,B)\subseteq\Mor_\mathcal{C}(B,B)$는 $\id_B\in\Mor_\mathcal{C}(B,B)$를 항상 포함한다.

</div>

그럼 자연스러운 *inclusion functor* $\mathcal{B}\rightarrow\mathcal{C}$가 잘 정의된다. 이를 일반화한 개념이 *faithful functor*다.

<div class="definition" markdown="1">

<ins id="df7">**정의 7**</ins> 두 카테고리[^1] $\mathcal{A},\mathcal{B}$와 둘 사이의 functor $F:\mathcal{A}\rightarrow\mathcal{B}$가 주어졌다 하자.

1. $F$가 *faithful functor<sub>충실한 함자</sub>*라는 것은 각각의 $A,A'\in\obj\mathcal{A}$마다 정의된 함수 
    
    $$\Mor_\mathcal{A}(A,A')\rightarrow\Mor_\mathcal{B}(FA,FA');\qquad f\mapsto F(f)$$

    가 단사인 것이다.
2. $F$가 *full functor<sub>충만한 함자</sub>*라는 것은 각각의 $A,A'\in\obj\mathcal{A}$마다 정의된 함수 
    
    $$\Mor_\mathcal{A}(A,A')\rightarrow\Mor_\mathcal{B}(FA,FA');\qquad f\mapsto F(f)$$

    가 전사인 것이다.

</div>

Inclusion functor $\mathcal{B}\rightarrow\mathcal{C}$는 항상 faithful functor가 된다. 만일 여기에 더하여, inclusion functor가 full functor라면 $\mathcal{B}$를 $\mathcal{C}$의 *full subcategory<sub>충만한 부분카테고리</sub>*라 부른다.

<div class="example" markdown="1">

<ins id="ex8">**예시 8 (Skeletal subcategory)**</ins> 임의의 카테고리 $\mathcal{C}$에 대하여, 그 subcategory $\mathcal{B}$가 *skeletal subcategory*라는 것은 $\mathcal{B}$가 $\mathcal{C}$의 full subcategory이고, 각각의 $C\in\obj(\mathcal{C})$와 isomorphic한 $\obj(\mathcal{B})$의 원소들이 정확하게 하나씩 존재하는 것이다.

이러한 상황에서, $\mathcal{C}$는 뼈대 $\mathcal{B}$에, isomorphic한 대상들을 추가하여 살을 붙여서 만들어진 카테고리로 생각할 수 있다.

</div>

Natural transformation
Abelian category
Adjoint pair
Representables
Yoneda lemma
Limit
Monad
Operad
Kan extension
Higher category
Infinite category
A infinity category



---

**참고문헌**

**[Lei]** T. Leinster. <i>Basic Category Theory</i>. Cambridge Studies in Advanced Mathematics, Cambridge University Press, 2014.  
**[Rie]** E. Riehl. <i>Category Theory in Context</i>. Dover Publications, 2017. [링크](https://emilyriehl.github.io/files/context.pdf)

---

[^1]: 엄밀히 말하자면 *국소적으로 작은* 카테고리들이어야 정의가 말이 되지만, 우리는 이런 이슈들은 무시하기로 하였다.